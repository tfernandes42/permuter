package com.newsbank.permuter.permutation;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import com.newsbank.permuter.PermutedResult;
import com.newsbank.permuter.net.GatewaySearch;
import com.newsbank.permuter.types.Person;
import com.newsbank.permuter.types.Relations;
import com.newsbank.permuter.types.Terms;

public class FormPermuter extends AbstractPermutation {

	private final static Logger kLogger = Logger.getLogger(FormPermuter.class);
	private String extraQuery = null;
	private String containerQuery = null;

	public Relations process(String fileData)
	{
		Relations r = new Relations();
		SAXBuilder builder = new SAXBuilder();

		try
		{
			Document document = (Document) builder.build(new StringReader(fileData));

			//root element (personSearch)
			Element rootNode = document.getRootElement();
			handleNode(rootNode);

			Set<String> primaryKeys = new HashSet<String>();
			List <String> organs = new ArrayList <String>();
			List <String> organs2 = new ArrayList <String>();
			String primKey = null;
			int num = 0;

			//create primary persons elements list
			@SuppressWarnings("unchecked")
			List<Element> primList = rootNode.getChildren("primary");
			
			//gateway option trigger
			if (rootNode.getChild("gateway") != null)
			{
				extraQuery = rootNode.getChildText("gateway").trim();
				if (rootNode.getChild("scorelimit") != null)
				{
					extraQuery = extraQuery + "&scorelimit=" + Integer.parseInt(rootNode.getChildText("scorelimit"));
				}
				if (rootNode.getChild("option") != null)
				{
					extraQuery = extraQuery + "&option=" + rootNode.getChildText("option");
				}
			}
			
			//container-query trigger
			if (rootNode.getChild("model") != null)
			{
				containerQuery = rootNode.getChildText("model").trim();
			}
			
			//set primary orgs
			initOrgs(primList,organs);

			//set primary person(s)
			if (rootNode.getChildren("primary").isEmpty()) 
			{
				Person primaryPerson = new Person();

				Element e = rootNode.addContent("primary");
				e.addContent("nameFirst");
				primaryPerson.setNameFirst(e.getChildText("nameFirst"));
				r.setPrimaries(e.getChildText("nameFirst"), primaryPerson);
				
			} else {
				
				for (int i = 0; i < primList.size(); i++) 
				{
					//handleNode(rootNode);
					Element node = primList.get(i);				
					Person primaryPerson = new Person();
					
					primaryPerson.setOrg(organs);
					primaryPerson.setNameFirst(node.getChildText("nameFirst"));
					primaryPerson.setNameMid(node.getChildText("nameMid"));
					primaryPerson.setNameNick(node.getChildText("nameNick"));
					primaryPerson.setBirthLast(node.getChildText("birthLast"));
					primaryPerson.setNameLast(node.getChildText("nameLast"));
					primaryPerson.setRelationship(node.getChildText("relationship"));
					/*if (node.getChildText("gender") != null) {
						primaryPerson.setGender(Person.Gender.valueOf(node.getChildText("gender").toUpperCase()));
					}*/

					primKey = node.getChildText("nameFirst") + num++;
					primaryKeys.add(primKey);

					r.setPrimaries(primKey, primaryPerson);
					//r = new Relations(primaryPerson);
					
					//set nameVar
					if (node.getChildText("nameVar") != null)
					{
						String nameVar = null;

						@SuppressWarnings("unchecked")
						List<Element> nameVars = node.getChildren("nameVar");
						for (int x = 0; x < nameVars.size(); x++)
						{
							Person primaryPerson2 = new Person();
							Element varNode = nameVars.get(x);
							nameVar = removePreSuff(varNode.getText());
							
							//kLogger.debug("nameVar: " + nameVar);
							
							//if nameVar only includes one name
							if (nameVar != null && !nameVar.contains(" "))
							{
								primaryPerson2.setNameLast(nameVar);
							}
							else 
							{
								String [] namePieces = nameVar.split(" ");
								
								if (namePieces != null && namePieces.length == 4)
								{
									primaryPerson2.setNameFirst(namePieces[0]);
									primaryPerson2.setNameMid(namePieces[1]);
									primaryPerson2.setBirthLast(namePieces[2]);
									primaryPerson2.setNameLast(namePieces[3]);
								}
								else if (namePieces != null && namePieces.length == 3)
								{
									primaryPerson2.setNameFirst(namePieces[0]);
									primaryPerson2.setNameMid(namePieces[1]);
									primaryPerson2.setNameLast(namePieces[2]);
								}
								else if (namePieces != null && namePieces.length == 2)
								{
									primaryPerson2.setNameFirst(namePieces[0]);
									primaryPerson2.setNameLast(namePieces[1]);
								}
							}
							r.setPrimaries(nameVar, primaryPerson2);	
						}
					}
				}
			}
			
			//create second persons elements list
			@SuppressWarnings("unchecked")
			List<Element> list = rootNode.getChildren("second");
			Iterator<Element> it1 = list.iterator();
			
			//set second orgs
			initOrgs(list,organs2);
			
			//set second persons
			while (it1.hasNext()) 
			{
				Element node = (Element)it1.next();				
					
				Person secondaryPerson = new Person();
				
				secondaryPerson.setOrg(organs2);
				secondaryPerson.setNameFirst(node.getChildText("nameFirst"));
				secondaryPerson.setNameMid(node.getChildText("nameMid"));
				secondaryPerson.setNameNick(node.getChildText("nameNick"));
				secondaryPerson.setBirthLast(node.getChildText("birthLast"));
				secondaryPerson.setNameLast(node.getChildText("nameLast"));
				secondaryPerson.setRelationship(node.getChildText("relationship"));
				/*if (node2.getChildText("gender") != null) {
					secondaryPerson.setGender(Person.Gender.valueOf(node2.getChildText("gender").toUpperCase()));
				}*/
				r.setRelatives(primKey, secondaryPerson);	
			}

			//trigger married name permutations --------------------------------------------------------------------------------
			//~~~~~~~a~~~~~~~~~~~~
			Iterator<String> primKeys = primaryKeys.iterator();
			List<Person> prims = new ArrayList<Person>();
			String pKey = null;
			boolean primBool = false;
			
			while (primKeys.hasNext())
			{
				pKey = primKeys.next();
				prims = r.getPrimaries(pKey);
			
				for (int i = 0; i < prims.size(); i++) 
				{
					Person primPerson = prims.get(i);
					//if primary has a birthLast but not a nameLast 
					if ( primPerson.getBirthLast() != null && primPerson.getNameLast() == null )
					{
						//for loop through secondaries
						List<Person> relList = r.getRelatives(primKey);
						for (Person rel : relList)
						{
							//see if any relatives are spouses and have a name last 
							if (rel.getNameLast()!=null && rel.getRelationship()!=null && ( rel.getRelationship().toUpperCase().contains("SPOUSE") || rel.getRelationship().toUpperCase().contains("WIFE") ||
									rel.getRelationship().toUpperCase().contains("HUSBAND") || rel.getRelationship().toUpperCase().contains("EX-WIFE") ||
									rel.getRelationship().toUpperCase().contains("EX-HUSBAND") || rel.getRelationship().toUpperCase().contains("FIANCE")||
									rel.getRelationship().toUpperCase().contains("DOMESTIC PARTNER") ) )
							{
								//grab spouses' last name and add to primary person nameLast if there is only one spouse
								if (relList != null && relList.size() == 1)
								{
									primPerson.setNameLast(rel.getNameLast());
								}
								//if there are more than one spouses create new primary person
								else 
								{
									if (rel != null && !rel.getNameLast().equalsIgnoreCase(primPerson.getBirthLast())) 
									{
										Person person = new Person();
										if (primPerson.getNameFirst()!=null)
										{
											person.setNameFirst(primPerson.getNameFirst());
										}
										if (primPerson.getNameMid()!=null)
										{
											person.setNameMid(primPerson.getNameMid());
										}
										if (primPerson.getNameNick()!=null)
										{
											person.setNameNick(primPerson.getNameNick());
										}
										person.setBirthLast(primPerson.getBirthLast());
										person.setNameLast(rel.getNameLast());	
										
										if (primBool == true)
										{
											primKey = primKey + num++;
										}
										//add new person to r
										r.setPrimaries(primKey, person);
										
										primBool = true;
									}
								}
							}
						}	
					}
					//~~~~~~~b~~~~~~~~~~~~
					//for loop through secondaries
					if( primPerson.getNameLast() != null )
					{
						List<Person> relList = r.getRelatives(primKey);
						if (relList != null)
						{
							for(Person rel : relList)
							{
								//see if any relatives are spouses and have a birthLast that is not the same at primary nameLast 
							 	if (rel.getRelationship()!=null && rel.getNameLast()==null && rel.getBirthLast()!=null && !primPerson.getNameLast().equalsIgnoreCase(rel.getBirthLast())
										&& ( rel.getRelationship().toUpperCase().contains("SPOUSE") || rel.getRelationship().toUpperCase().contains("WIFE") ||
										rel.getRelationship().toUpperCase().contains("HUSBAND") || rel.getRelationship().toUpperCase().contains("EX-WIFE") ||
										rel.getRelationship().toUpperCase().contains("EX-HUSBAND") || rel.getRelationship().toUpperCase().contains("FIANCE")||
										rel.getRelationship().toUpperCase().contains("DOMESTIC PARTNER") ) )
								{
									rel.setNameLast(primPerson.getNameLast());
								}
							}
						}
					}
				}
			}
			//-------------------------------------------------------------------------------------------
			//get terms and set them to terms ArrayList 
			List<?> termsList = rootNode.getChildren("terms");
			String termKey = "all";
			String xmlTerm = "term";
			setTerms(xmlTerm, termKey, r, termsList);
			
			//getNotterms and add them to notterms ArrayList 
			List<?> nottermsList = rootNode.getChildren("notterms");
			termKey = "allnot";
			xmlTerm = "notterm";
			setTerms(xmlTerm, termKey, r, nottermsList);
			
		}catch (Throwable io) {
				io.printStackTrace(System.err);
			 } 
		return r;
	}

	public String permute(Relations r) 
	{
		StringBuilder trip= new StringBuilder();
		StringBuilder init = new StringBuilder();
		List<String> spouses = new ArrayList<String>();

		List <String> org = new ArrayList <String>();
	 	String nameFirst = null;
		String nameMid = null;
		String nameNick = null;
		String birthLast = null;
		String nameLast = null;
	 	String fNameFirst = null;
		//String fNameNick = null;
	 	String fBirthLast = null;
		String fNameLast = null;
		//Gender gender = null;
		char nameFirstInitial = 0;
		char nameMidInitial = 0;
		char birthLastInitial = 0;
		String midInit = null;
		char midInit0 = 0;
		char sMnInit0 = 0;
		String sMnInit = null;
		String sMid = null;
		String sBlast = null;
		String theKey = null;
		String mid = null;
		String firstN = null;
		boolean first = false; //for coupleRefs		
		
		//set extra query if form contains gateway element
		if (extraQuery != null) 
		{
			trip.append(extraQuery);
		}
		trip.append("&p_field_primary-0=alltext&p_params_primary-0=weight:1&p_text_primary-0=(");

		//for loop to iterate through all the relatives in r
		Map <String, List<Person>> primaries = r.getPrimaries();
		Iterator<String> itPrimary = primaries.keySet().iterator();
		while (itPrimary.hasNext())
		{
			theKey = itPrimary.next();
			//kLogger.debug("Relatives:" + theKey);
			
			//iterate through all primary keys
			List<Person> personList = primaries.get(theKey);
			for(Person primary : personList)
			{
				org = primary.getOrg();
			 	nameFirst = primary.getNameFirst();
				nameMid = primary.getNameMid();
				nameNick = primary.getNameNick();
				birthLast = primary.getBirthLast();
				nameLast = primary.getNameLast();
				//gender = primary.getGender();
				
				//get initials of useful names
				if (nameFirst != null) 
				{
					//take out any quotation
					if (nameFirst.contains("\""))
					{
						nameFirst = nameFirst.replace("\"", "");
					}
					nameFirst = removeEndPer(nameFirst);
					nameFirstInitial = nameFirst.charAt(0);
				}
				if (nameMid != null) 
				{
					//take out any quotation
					if(nameMid.contains("\""))
					{
						nameMid = nameMid.replace("\"", "");
					}
					nameMid = removeEndPer(nameMid);
					nameMidInitial = nameMid.charAt(0);
					sMid = Character.toString(nameMidInitial);
				}
				if (birthLast != null) 
				{
					//take out any quotation
					if(birthLast.contains("\""))
					{
						birthLast = birthLast.replace("\"", "");
					}
					birthLast = removeEndPer(birthLast);
					birthLastInitial = birthLast.charAt(0);
					sBlast = Character.toString(birthLastInitial);
				}
				
				//take out any quotation
				if (nameLast != null && nameLast.contains("\""))
				{
					nameLast = nameLast.replace("\"", "");
				}
				nameLast = removeEndPer(nameLast);
				
				//take out any quotation
				if (nameNick != null && nameNick.contains("\""))
				{
					nameNick = nameNick.replace("\"", "");
				}
				nameNick = removeEndPer(nameNick);
				
				//if nameMid has more than one parts 
				String nameMids = null;
				if (nameMid != null && nameMid.contains(" "))
				{
					String [] nm = nameMid.split(" ");
					StringBuilder nm2= new StringBuilder();
					
					for(int i = 0; i < nm.length; i++) 
					{
						nm2.append(nm[i].charAt(0) + " ");
					}
					nameMids = nm2.toString();
				}
				
				//set up for coupleRefs
				if (first == false) 
				{
					fNameFirst = nameFirst;
					fBirthLast = birthLast;
					fNameLast = nameLast;
	
					/*if (nameNick != null) {
						fNameNick = nameNick;
					}*/
				}
				
				//boolean to state weather first or not first primary person (first = true once first primary has passed)
				first = true;
				
				//call and append primary person permutations to trip
				trip.append( primary.primPermute(init, nameFirstInitial, nameMidInitial, birthLastInitial, nameMids, sMid, sBlast) );
			}
		}
		trip.append(")");
		String str1 = trip.toString().substring(trip.indexOf("(") +1, trip.indexOf(")"));
		String str2 = deleteDup(str1,nameFirst,nameLast,birthLast);

		if (init != null && !init.toString().isEmpty()) 
		{
			trip.append("&p_bool_primary-1=OR&p_field_primary-1=alltext&p_params_primary-1=weight:0&p_text_primary-1=(" +
		init + ")");
		}
		
		//===================================================
		//start building PRIMARY couple ref 
		//===================================================
		String [] all = {"WIFE", "HUSBAND", "SPOUSE", "EX-WIFE","EX-HUSBAND", "FIANCE", "DOMESTIC PARTNER"};
		StringBuffer onear2 = new StringBuffer();
		
		trip.append("&p_bool_primary-2=OR&p_field_primary-2=alltext&p_params_primary-2=weight:1&p_text_primary-2=(");
		if (!r.getRelatives().isEmpty()) 
		{
			//for loop to make this iterate through all the relatives in r
			Map <String, List<Person>> relatives = r.getRelatives();
			Iterator<String> it=relatives.keySet().iterator();
			while (it.hasNext())
			{
				String theKey2 = it.next();
				List<Person> personList = relatives.get(theKey2);
				for(Person relative : personList)
				{
					for (int a = 0; a < all.length; a++)	
					{
						if (relative.getRelationship()!=null) 
						{
							if (relative.getRelationship().equalsIgnoreCase(all[a])) 
							{
								mid = relative.getNameMid();
								if (mid != null) 
								{	//take out any quotation
									if (mid.contains("\""))
									{
										mid = mid.replace("\"", "");
									}
									mid = removeEndPer(mid);
									midInit0 = relative.getNameMid().charAt(0);
									midInit = Character.toString(midInit0);
								}
	
								firstN = relative.getNameFirst();
								//take out any quotation
								if (firstN != null && firstN.contains("\""))
								{
									firstN = firstN.replace("\"", "");
								}
								firstN = removeEndPer(firstN);
								
								//save spouses first & mid name(if available) to construct second coupleRefs
								if (mid != null && relative.getNameLast() != null) 
								{
									spouses.add(firstN+" "+ mid+" "+ relative.getNameLast());
								}
								else if (mid == null && relative.getNameLast() != null) 
								{
									spouses.add(firstN+" "+ relative.getNameLast());
								}
								else
									spouses.add(firstN);
								
								//loop through primaries here 
								itPrimary=primaries.keySet().iterator();
								while (itPrimary.hasNext())
								{
									theKey = itPrimary.next();
									//kLogger.debug("Relatives:" + theKey);
									
									personList = primaries.get(theKey);
									for(Person primary : personList)
									{
								 	nameFirst = primary.getNameFirst();
									nameMid = primary.getNameMid();
									nameNick = primary.getNameNick();
									birthLast = primary.getBirthLast();
									nameLast = primary.getNameLast();
									
									//start forming coupleRefs
									if ( /*coupleRef == true &&*/ nameFirst != null && firstN != null && nameLast != null && nameLast.equalsIgnoreCase(relative.getNameLast()) ) 
									{
										if (nameFirst.length()>1)
										{
											trip.append("\"" +nameFirst + " " + firstN + " " + nameLast+ "\"");
											trip.append("\"" +nameFirst + " and " + firstN + " " + nameLast+ "\"");
											//primary-3
											if (nameMid==null&&mid==null) 
											{
												onear2.append("q0t3" +nameFirst + "q0t3 ONEAR/2 q0t3" + firstN  +"q0t3 ONEAR/2 q0t3"+ nameLast+ "q0t3");
												onear2.append("q0t3" +nameFirst + "q0t3 ONEAR/2 q0t3and " + firstN + "q0t3 ONEAR/2 q0t3" + nameLast+ "q0t3");
											}
											if (nameMid==null) 
											{
												onear2.append("q0t3" +nameFirst + "q0t3 ONEAR/2 q0t3" + firstN  +" "+ nameLast+ "q0t3");
												onear2.append("q0t3" +nameFirst + "q0t3 ONEAR/2 q0t3and " + firstN + " " + nameLast+ "q0t3");
											}
											//new
											if (mid==null) 
											{
												onear2.append("q0t3" +nameFirst + " " + firstN + "q0t3 ONEAR/2 q0t3" + nameLast+ "q0t3");
												onear2.append("q0t3" +nameFirst + " and " + firstN + "q0t3 ONEAR/2 q0t3" + nameLast+ "q0t3");
											}
										}
			
										if (nameMid != null) 
										{
											trip.append("\"" +nameFirst + " " + nameMid +" "+ firstN + " " + nameLast+ "\"");
											trip.append("\"" +nameFirst + " " + nameMid +" and "+ firstN + " " + nameLast+ "\"");
											//additional
											trip.append("\"" +nameFirst + " " + nameMidInitial +" "+ firstN + " " + nameLast+ "\"");
											trip.append("\"" +nameFirst + " " + nameMidInitial +" and "+ firstN + " " + nameLast+ "\"");
											//new
											if (mid==null) 
											{
												onear2.append("q0t3" +nameFirst + " " + nameMid +" "+ firstN + "q0t3 ONEAR/2 q0t3" + nameLast+ "q0t3");
												onear2.append("q0t3" +nameFirst + " " + nameMid +" and "+ firstN + "q0t3 ONEAR/2 q0t3" + nameLast+ "q0t3");
												//missing one
												onear2.append("q0t3" +nameFirst + " " + nameMidInitial +" "+ firstN + "q0t3 ONEAR/2 q0t3" + nameLast+ "q0t3");
												onear2.append("q0t3" +nameFirst + " " + nameMidInitial +" and "+ firstN + "q0t3 ONEAR/2 q0t3" + nameLast+ "q0t3");
											}
										}
										if (mid != null&&nameFirst.length()>1) 
										{
											trip.append("\"" +nameFirst + " " + firstN + " " + mid +" "+ nameLast+ "\"");
											trip.append("\"" +nameFirst + " and " + firstN + " " + mid +" "+ nameLast+ "\"");
											//additional 
											trip.append("\"" +nameFirst + " " + firstN + " " + midInit +" "+ nameLast+ "\"");
											trip.append("\"" +nameFirst + " and " + firstN + " " + midInit +" "+ nameLast+ "\"");
											//primary-3
											if(nameMid==null) 
											{
												onear2.append("q0t3" +nameFirst + "q0t3 ONEAR/2 q0t3" + firstN + " " + mid +" "+ nameLast+ "q0t3");
												onear2.append("q0t3" +nameFirst + "q0t3 ONEAR/2 q0t3and " + firstN + " " + mid +" "+ nameLast+ "q0t3");
												//missing one
												onear2.append("q0t3" +nameFirst + "q0t3 ONEAR/2 q0t3" + firstN + " " + midInit +" "+ nameLast+ "q0t3");
												onear2.append("q0t3" +nameFirst + "q0t3 ONEAR/2 q0t3and " + firstN + " " + midInit +" "+ nameLast+ "q0t3");
											}
										}
										if ( mid != null && nameMid != null) 
										{
											trip.append("\"" +nameFirst + " " + nameMid +" "+ firstN + " " + mid +" "+ nameLast+ "\"");
											trip.append("\"" +nameFirst + " " + nameMid +" and "+ firstN + " " + mid +" "+ nameLast+ "\"");
											//additional 
											trip.append("\"" +nameFirst + " " + nameMidInitial +" "+ firstN + " " + midInit +" "+ nameLast+ "\"");
											trip.append("\"" +nameFirst + " " + nameMidInitial +" and "+ firstN + " " + midInit +" "+ nameLast+ "\"");
											//extra
											trip.append("\"" +nameFirst + " " + nameMid +" "+ firstN + " " + midInit +" "+ nameLast+ "\"");
											trip.append("\"" +nameFirst + " " + nameMid +" and "+ firstN + " " + midInit +" "+ nameLast+ "\"");
											trip.append("\"" +nameFirst + " " + nameMidInitial +" "+ firstN + " " + mid +" "+ nameLast+ "\"");
											trip.append("\"" +nameFirst + " " + nameMidInitial +" and "+ firstN + " " + mid +" "+ nameLast+ "\"");
											}
										}
										//finish looping through primaries
									}
								}		
							}
							//or here mid=null;
						}
						 mid=null;
					}
				}
			}
		}
		trip.append(")");
		//add to second-7
		String prim2 = deleteDup(trip.toString().substring(trip.indexOf("primary-2=(") + 11, trip.length()-1), nameFirst, nameLast, birthLast);
		
		if(trip.toString().contains("&p_bool_primary-2=OR&p_field_primary-2=alltext&p_params_primary-2=weight:1&p_text_primary-2=()")) 
		{
			trip.delete(trip.length() - 94, trip.length());
		}
		
		if(onear2 != null && !onear2.toString().isEmpty()) 
		{
			trip.append("&p_bool_primary-3=OR&p_field_primary-3=alltext&p_params_primary-3=weight:0&p_text_primary-3=(" +
		onear2 + ")");
		}
		
		String prim4 = null;
		//add primary-4 for org
		if(org != null && !org.isEmpty())
		{		
			trip.append("&p_bool_primary-4=OR&p_field_primary-4=alltext&p_params_primary-4=weight:1&p_text_primary-4=(");
			Iterator<String> oit = org.iterator();
			while (oit.hasNext())
			{
				String o = oit.next().toString();
				o = orgPermuter(o);
				trip.append(o);
			}
			trip.append(")");
			//add to second-10 -- maybe delete because already taken care of in orgPermuter method
			prim4 = deleteDup(trip.toString().substring(trip.indexOf("primary-4=(") + 11, trip.length()-1), nameFirst, nameLast, birthLast);
		}

			//===================================================
			//start building relatives trip
			//===================================================
			trip.append("&p_field_second-0=alltext&p_params_second-0=weight:1&p_text_second-0=(");	
			
			List<String> orgs = new ArrayList<String>();
			//for loop to make this iterate through all the relatives in r
			Map <String, List<Person>> relatives = r.getRelatives();
			Iterator<String> it=relatives.keySet().iterator();
			while (it.hasNext())
			{
				String theKey2 = it.next();
				//kLogger.debug("Relatives:" + theKey);
				
				List<Person> personList = relatives.get(theKey2);
				for(Person relative : personList)
				{
					orgs = relative.getOrg();
					String relNameFirst = relative.getNameFirst();
					String relNameMid = relative.getNameMid();
					String relNameNick = relative.getNameNick();
					String relNameLast = relative.getNameLast();
					String relBirthLast = relative.getBirthLast();
					//String relationship = relative.getRelationship();
					//Gender relGender = relative.getGender();
					char relNameMidInitial = 0;
					char relBirthLastInitial = 0;
					char relNameFirstInitial = 0;
					String sRelMid = null;
					String sRelBlast = null;
		
					//set initials & fix necessary names ==========================================================
					if(relNameFirst != null) 
					{
						//take out any quotation
						if(relNameFirst.contains("\""))
						{
							relNameFirst = relNameFirst.replace("\"", "");
						}
						relNameFirst = removeEndPer(relNameFirst);
						relNameFirstInitial = relNameFirst.charAt(0);
					}
					if(relNameMid != null) 
					{
						//take out any quotation
						if(relNameMid.contains("\""))
						{
							relNameMid = relNameMid.replace("\"", "");
						}
						relNameMid = removeEndPer(relNameMid);
						relNameMidInitial = relNameMid.charAt(0);
						sRelMid = Character.toString(relNameMidInitial);
					}
					if(relBirthLast != null) 
					{
						//take out any quotation
						if(relBirthLast.contains("\""))
						{
							relBirthLast = relBirthLast.replace("\"", "");
						}
						relBirthLast = removeEndPer(relBirthLast);
						relBirthLastInitial = relBirthLast.charAt(0);
						sRelBlast = Character.toString(relBirthLastInitial);
					}
					//take out any quotation
					if(relNameLast != null && relNameLast.contains("\""))
					{
						relNameLast = relNameLast.replace("\"", "");
					}
					relNameLast = removeEndPer(relNameLast);
					//take out any quotation
					if(relNameNick != null && relNameNick.contains("\""))
					{
						relNameNick = relNameNick.replace("\"", "");
					}
					relNameNick = removeEndPer(relNameNick);
					//==========================================================
					
					//if nameMid has more than one parts 
					String relNameMids = null;
					if(relNameMid != null && relNameMid.contains(" ")) 
					{
						String [] nm = relNameMid.split(" ");
						StringBuilder nm2= new StringBuilder();
						
						for(int i = 0; i < nm.length; i++) 
						{
							nm2.append(nm[i].charAt(0) + " ");
						}
						relNameMids = nm2.toString();
					}
					
					//call and append second persons permutations to trip
					trip.append( relative.secPermute(relNameFirstInitial, relNameMidInitial, relBirthLastInitial, fNameFirst, fBirthLast, fNameLast, relNameMids, sRelMid, sRelBlast) );					
				}
			}
			
			trip.append(")");
			if(trip.toString().contains("&p_field_second-0=alltext&p_params_second-0=weight:1&p_text_second-0=()")) 
			{
				trip.delete(trip.length() - 71, trip.length());
			}

			//===================================================
			//start building sec coupleRef 
			//===================================================
			//populate
			String spouse = null;
			String [] split;
			String sFn = null;
			String sMn = null;
			String sLn = null;
			trip.append("&p_bool_second-2=OR&p_field_second-2=alltext&p_params_second-2=weight:1&p_text_second-2=(");
			
			for (int i = 0; i < spouses.size(); i++)
			{
				//if(coupleRef == true){
					spouse = spouses.get(i).trim();
					if(spouse.contains(" ")) 
					{	
						//if spouse has any double space 
						if(spouse.contains("  "))
						{
							spouse = spouse.replace("  ", " ");
						}
						split = spouse.split(" ");
						
						//if spouse has first, mid, last
						if(split.length == 3)
						{
							sFn=split[0];
							sMn=split[1];
							sLn=split[2];
						}
						
						//if spouse has first & last
						if(split.length == 2)
						{
							sFn=split[0];
							sLn=split[1];
						}
					}
					else
						sFn = spouse;
					
					//take out any quotation
					if(sFn.contains("\""))
					{
						sFn = sFn.replace("\"", "");
					}
					sFn = removeEndPer(sFn);
					
					if(sMn != null) 
					{
						//take out any quotation
						if(sMn.contains("\""))
						{
							sMn = sMn.replace("\"", "");
						}
						sMn = removeEndPer(sMn);
						sMnInit0 = sMn.charAt(0);
						sMnInit = Character.toString(sMnInit0);
					}
	
					//loop through primaries here 
					itPrimary=primaries.keySet().iterator();
					while (itPrimary.hasNext())
					{
						theKey = itPrimary.next();
						//kLogger.debug("Relatives:" + theKey);
						
						List<Person> personList = primaries.get(theKey);
						for(Person primary : personList)
						{
							nameFirst = primary.getNameFirst();
							nameMid = primary.getNameMid();
							nameNick = primary.getNameNick();
							birthLast = primary.getBirthLast();
							nameLast = primary.getNameLast();
							
							if(nameFirst!= null && sFn != null && nameLast!=null && nameLast.equalsIgnoreCase(sLn)) 
								{
							if(sFn.length()>1)
							{
								trip.append("\"" + sFn + " " + nameFirst+ " " + nameLast+ "\"");
								trip.append("\"" + sFn + " and " +  nameFirst + " " + nameLast+ "\"");
							
								if(nameMid != null) 
								{
									trip.append("\"" +sFn + " " +nameFirst + " " + nameMid +" "+  nameLast+ "\"");
									trip.append("\"" + sFn + " and "  +nameFirst + " " + nameMid +" "+ nameLast+ "\"");
									//additional
									trip.append("\"" +sFn + " " +nameFirst + " " + nameMidInitial +" "+  nameLast+ "\"");
									trip.append("\"" + sFn + " and "  +nameFirst + " " + nameMidInitial +" "+ nameLast+ "\"");
								}
							}
							
							if(sMn != null) 
							{
								trip.append("\"" + sFn + " "+ sMn +" "+nameFirst + " "  + nameLast+ "\"");
								trip.append("\"" + sFn + " "+ sMn +" and "+nameFirst + " " + nameLast+ "\"");
								//additional
								trip.append("\"" + sFn + " "+ sMnInit +" "+nameFirst + " "  + nameLast+ "\"");
								trip.append("\"" + sFn + " "+ sMnInit +" and "+nameFirst + " " + nameLast+ "\"");
							}
							if( sMn != null && nameMid != null) 
							{
								trip.append("\"" + sFn + " " + sMn +" "+nameFirst + " " + nameMid +" "+ nameLast+ "\"");
								trip.append("\"" + sFn + " " + sMn +" and "+nameFirst + " " + nameMid +" "+ nameLast+ "\"");
								//additional
								trip.append("\"" + sFn + " " + sMnInit +" "+nameFirst + " " + nameMidInitial +" "+ nameLast+ "\"");
								trip.append("\"" + sFn + " " + sMnInit +" and "+nameFirst + " " + nameMidInitial +" "+ nameLast+ "\"");
								//extra
								trip.append("\"" + sFn + " " + sMn +" "+nameFirst + " " + nameMidInitial +" "+ nameLast+ "\"");
								trip.append("\"" + sFn + " " + sMn +" and "+nameFirst + " " + nameMidInitial +" "+ nameLast+ "\"");
								trip.append("\"" + sFn + " " + sMnInit +" "+nameFirst + " " + nameMid +" "+ nameLast+ "\"");
								trip.append("\"" + sFn + " " + sMnInit +" and "+nameFirst + " " + nameMid +" "+ nameLast+ "\"");						
								}
							}
						}
					}
					sMn = null;
				//}
			}
			
			trip.append(")");
			
			if(trip.toString().contains("&p_bool_second-2=OR&p_field_second-2=alltext&p_params_second-2=weight:1&p_text_second-2=()")) 
			{
				trip.delete(trip.length() - 90, trip.length());
			}

			//===================================================
			//start building terms trip
			//===================================================
			List<Terms> termsList = r.getTerms("all");
			if(termsList != null)
			{
				trip.append("&p_bool_second-4=OR&p_field_second-4=alltext&p_params_second-4=weight:1&p_text_second-4=(");
				addTerms(termsList,trip);
				trip.append(")");
			}

			trip.append("&p_bool_second-5=OR&p_field_second-5=alltext&p_params_second-5=weight:0&p_text_second-5=(");
			
			StringBuilder t = new StringBuilder();
			t.append(deleteDup(trip.toString(), nameFirst, nameLast, birthLast));
			
			t.append(str2 + ")");
			
			if(t.toString().contains("&p_bool_second-5=OR&p_field_second-5=alltext&p_params_second-5=weight:0&p_text_second-5=()")) 
			{
				t.delete(t.length()-90, t.length());
			}
			
			if(init != null && !init.toString().isEmpty()) 
			{
				String initFinal = deleteDup(init.toString(),"first","second","third");
				t.append("&p_bool_second-6=OR&p_field_second-6=alltext&p_params_second-6=weight:0&p_text_second-6=(" +initFinal+ ")");
			}
			if(prim2 != null && !prim2.equals("")) 
			{
				t.append("&p_bool_second-7=OR&p_field_second-7=alltext&p_params_second-7=weight:0&p_text_second-7=(" +prim2+ ")");
			}
			if(onear2 != null && !onear2.toString().isEmpty()) 
			{
				t.append("&p_bool_second-8=OR&p_field_second-8=alltext&p_params_second-8=weight:0&p_text_second-8=(" +onear2+ ")");
			}
	
			if(orgs != null && !orgs.isEmpty()) 
			{
				t.append("&p_bool_second-9=OR&p_field_second-9=alltext&p_params_second-9=weight:1&p_text_second-9=(");
				Iterator<String> orgsIt = orgs.iterator();
				while (orgsIt.hasNext())
					{
						String o = orgsIt.next().toString();
						t.append("\"" +o+ "\"");
					}
				t.append(")");
			}
			
			if(prim4 != null && !prim4.equals("")) 
			{
				t.append("&p_bool_second-10=OR&p_field_second-10=alltext&p_params_second-10=weight:0&p_text_second-10=(" +prim4+ ")");
			}
			
			//-------------------------- add notterms --------------------------
			List<Terms> termsList2 = r.getTerms("allnot");
			if(termsList2 != null)
			{
				t.append("&p_bool_notterms-0=NOT&p_field_notterms-0=alltext&p_text_notterms-0=(");
				addTerms(termsList2,t);
				t.append(")");
			}
			
			StringBuilder t2 = new StringBuilder();
			StringBuilder triplets = new StringBuilder();
			
			String tee = t.toString().replaceAll("q0t3", "\"");
			t = new StringBuilder();
			t.append(tee);
			
			t2.append(addOr(t));
			
			String tpl = triplets.append(replaceAmp(t2)).toString();
			
			if(tpl.contains("  ")) 
			{
				tpl = tpl.replace("  ", " ");
			}
			
			String container = "\n"+tpl;
			if(containerQuery != null && !containerQuery.toUpperCase().equals("DEFAULT"))
			{	
				container = container.replace("alltext", "allfs");
				container = container.replace("primary-", "primary-10");
				container = container.replace("second-", "second-10");
				//change allfs to personName in obit and census 
				container = container.replace("&p_field_primary-100=allfs","&p_field_primary-100=personName");
				container = container.replace("&p_field_primary-101=allfs","&p_field_primary-101=personName");
				//container = container.replace("&p_field_primary-102=allfs","&p_field_primary-102=personName");
				//container = container.replace("&p_field_primary-103=allfs","&p_field_primary-103=personName");
				container = container.replace("&p_field_second-105=allfs","&p_field_second-105=personName");
				container = container.replace("&p_field_second-106=allfs","&p_field_second-106=personName");
				//container = container.replace("&p_field_second-107=allfs","&p_field_second-107=personName");
				//container = container.replace("&p_field_second-108=allfs","&p_field_second-108=personName");
				//remove primary-102,primary-103,second-102 (second-103 removed due to the removal of second-3)
				if(container.contains("&p_bool_primary-102="))
				{
					String prim102 = container.substring(container.indexOf("&p_bool_primary-102="), container.indexOf(")&", container.indexOf("primary-102=("))) + ")";
					container = container.replace(prim102,"");
				}
				if(container.contains("&p_bool_primary-103="))
				{
					String prim103 = container.substring(container.indexOf("&p_bool_primary-103="), container.indexOf(")&", container.indexOf("primary-103=("))) + ")";
					container = container.replace(prim103,"");
				}
				if(container.contains("&p_bool_second-102="))
				{
					String sec102 = container.substring(container.indexOf("&p_bool_second-102="), container.indexOf(")&", container.indexOf("second-102=("))) + ")";
					container = container.replace(sec102,"");
				}
				if(container.contains("&p_bool_second-107="))
				{
					String sec107 = container.substring(container.indexOf("&p_bool_second-107="), container.indexOf(")&", container.indexOf("second-107=("))) + ")";
					container = container.replace(sec107,"");
				}
				if(container.contains("&p_bool_second-108="))
				{
					String sec108 = container.substring(container.indexOf("&p_bool_second-108="), container.indexOf(")", container.indexOf("second-108=("))) + ")";
					container = container.replace(sec108,"");
				}
				//kLogger.debug("prim102: " + prim102);

				container = container + "&p_bool_primary-100=OR&p_bool_second-100=OR";
				if(containerQuery.toUpperCase().equals("OBIT")) 
				{
					container = container + "&p_container_primary-100=person:1:obit&p_container_primary-101=person:1:obit&p_container_second-105=person:1:obit&p_container_second-106=person:1:obit";
					tpl = tpl.replace("field_primary-0=alltext", "field_primary-0=dece");
					tpl = tpl.replace("field_primary-1=alltext", "field_primary-1=dece");
					tpl = tpl.replace("field_primary-2=alltext", "field_primary-2=dece");
					tpl = tpl.replace("field_primary-3=alltext", "field_primary-3=dece");
					tpl = tpl.replace("field_second-5=alltext", "field_second-5=dece");
					tpl = tpl.replace("field_second-6=alltext", "field_second-6=dece");
					tpl = tpl.replace("field_second-7=alltext", "field_second-7=dece");
					tpl = tpl.replace("field_second-8=alltext", "field_second-8=dece");
				}
				else if(containerQuery.toUpperCase().equals("CENSUS")) 
				{
					container = container + "&p_container_primary-100=person:1:census&p_container_primary-101=person:1:census&p_container_second-105=person:1:census&p_container_second-106=person:1:census";
				}
				tpl = tpl + container;
			}
			
			//take out any double ORs
			/*if(tpl.contains(" OR OR "))
			{
				tpl = tpl.replace(" OR OR ", " OR ");
			}*/
			
			return
					tpl;
	}
	
	public String arrayToString(String [] arr)
	{
		//make Array a string
	    boolean pass = false;
	    StringBuilder orgBuilder = new StringBuilder();
	    for(String s : arr) 
	    {   
		    if(pass == true)
		    {
		    	orgBuilder.append(" ");
		    }
		   
		    orgBuilder.append(s);
		    pass = true;
	    }
	    return orgBuilder.toString();
	}
	
	//org permutations
	public String orgPermuter(String o) 
	{		
		String [] stopwords = {"THE","AND","AT","BY","FOR","OF","ON","TO","DO","LA","DE"};
		String [] suffwords = {"GMBH","AG","CORP","PLC","S.A","SA","LTD","AB","INC","ASA","SA","S.P.A","SPA",
				"N.V","NV","AB","L.P","LP","DIV","COOP","L.L.C","LLC","KG","LTDA","S.A.S","SAS"};

		//If there is more than one word: remove stopwords from beginning
		if(o.contains(" "))
		{
			for(int y = 0; y < stopwords.length; y++)
			{
				String [] orgArr = o.split(" ");
				if(orgArr[0].equalsIgnoreCase(stopwords[y]))
				{
					orgArr = Arrays.copyOfRange(orgArr, 1, orgArr.length);
				}
				//make string array back into a string
				o = arrayToString(orgArr);
			}
		}
		
		//If there is still more than one word: remove suffix words from end (recursive)
		if(o.contains(" "))
		{
			for (int x = 0; x < suffwords.length; x++) 
			{
				String [] orgArr = o.split(" ");
				if(orgArr != null && orgArr.length > 0 && orgArr[orgArr.length-1].equalsIgnoreCase(suffwords[x]))
				{
					orgArr = Arrays.copyOfRange(orgArr, 0, orgArr.length-1);
					//added for recursion
					for (int y = 0; y < suffwords.length; y++) 
					{
						if(orgArr[orgArr.length-1].equalsIgnoreCase(suffwords[y]))
						{
							orgArr = Arrays.copyOfRange(orgArr, 0, orgArr.length-1);
						}
					}
				}
				o = arrayToString(orgArr);
			}
		}
	
		return  "\"" + o + "\"";
	}
	
	//remove prefix / suffix in nameVar
	public String removePreSuff(String nameVar)
	{
		//prefix & suffix
		String [] prefix = {"MISTER","MR","MISTRESS","MRS","MS","MISS","DOCTOR","DR","PROFESSOR","PROF","PR","FATHER","FR","PASTOR","PR",
				"BROTHER","BR","SISTER","SR","MOTHER","RABBI","REVEREND","REV","MONSIGNOR","MSGR", "ADMIRAL","ADM","MARSHAL","MAR",
				"SHERIFF","GENERAL","GEN","LIEUTENANT","LT","MAJOR","MAJ","COMMODORE","COM","BRIGADIER","BRIG","BR","CAPTAIN","CAPT",
				"COLONEL","COL","COMMANDER","OFFICER","OFF","ENSIGN","ENS","SERGEANT","SGT","CORPORAL","PRIVATE","PVT","SEAMAN","AIRMAN",
				"VICE","PRESIDENT","PRES"};
		String [] suffix = {"JR","SR","JNR","SNR","2ND","II","3RD","III","4TH","IV","PHD","DPHIL","MD","DO","PA","PA-C","NP","FNP","ANP","GNP","APNP",
				"DDS","JD","MCSA","MCP","VCP","MBA","ESQ","AB","BA","BS","MA","MS","MSC","KBE","CSA","ASCAP","MMFT","MSW","MAPC","MSED","PSYD",
				"LPSY","EDD","DMFT","DSW","AA","AS","LPC","LGPC","LCPC","LCSW","LCAT","LGSW","LAMFT","LMFT","LMHC","LCMHC","CMHC",
				"LPCC","LISW","LSW","LCMFT","CCPT","NCPC","NCCA"};

		nameVar = nameVar.replaceAll("[^\\p{L} ]", " ");
		//take out double spaces
		while (nameVar.contains("  ")) 
		{
			nameVar = nameVar.replace("  ", " ");	
		}
		   
		String [] personArr = nameVar.split(" ");
		String [] newPersonArr = null;
		boolean pre = false;
		boolean suff = false;
		
		//see if first part of nameArray includes any of the prefix's
		for (int x = 0; x < prefix.length; x++) 
		{
			if(personArr != null && personArr.length > 0 && personArr[0].equalsIgnoreCase(prefix[x]))
			{
				pre = true;
				newPersonArr = Arrays.copyOfRange(personArr, 1, personArr.length);
				//loop through all prefix options again for next word in name
				for (int y = 0; y < prefix.length; y++)
				{
					if(newPersonArr[0].equalsIgnoreCase(prefix[y]))
					{	
						newPersonArr = Arrays.copyOfRange(newPersonArr, 1, newPersonArr.length);
					}
				}
			}   
		}
	   
		//see if last two parts of newNameArr includes any of the suffix's
		for (int x = 0; x < suffix.length; x++) 
		{
			if(pre == true)
			{
				if(newPersonArr != null && newPersonArr.length > 0 && newPersonArr[newPersonArr.length-1].equalsIgnoreCase(suffix[x]))
				{
					suff = true;
					newPersonArr = Arrays.copyOfRange(newPersonArr, 0, newPersonArr.length-1);
					//added for recursion
					for (int y = 0; y < suffix.length; y++) 
					{
						if(newPersonArr[newPersonArr.length-1].equalsIgnoreCase(suffix[y]))
						{
							newPersonArr = Arrays.copyOfRange(newPersonArr, 0, newPersonArr.length-1);
						}
					}
				}
			}
			//if pre equals false
			else 
			{
				if(personArr != null && personArr.length > 0 && personArr[personArr.length-1].equalsIgnoreCase(suffix[x]))
				{
					suff = true;
					newPersonArr = Arrays.copyOfRange(personArr, 0, personArr.length-1);
					//added for recursion
					for (int y = 0; y < suffix.length; y++) 
					{
						if(newPersonArr[newPersonArr.length-1].equalsIgnoreCase(suffix[y]))
						{
							newPersonArr = Arrays.copyOfRange(newPersonArr, 0, newPersonArr.length-1);
						}
					}
				}	 
			}
		}
		
		//make newNameArr equal to nameArray if there were no pre / suff modifications
		if(pre == false && suff == false)
		{
			newPersonArr = personArr;
		}

		//make newPersonArr = nameVar
	    boolean pass = false;
	    StringBuilder nameBuilder = new StringBuilder();
	    for(String s : newPersonArr) 
	    {   
		    if(pass == true)
		    {
		 	   nameBuilder.append(" ");
		    }
		   
		    nameBuilder.append(s);
		    pass = true;
	    }
	    nameVar = nameBuilder.toString();
		   
	    return nameVar;
	}

	//method to remove period at the end of words/letters
	public static String removeEndPer(String str) 
	{
		if(str != null && str.length() > 0 && str.contains(". "))
		{
			str = str.replace(". ", " ");
		}
	    if (str != null && str.length() > 0 && str.charAt(str.length() - 1) == '.') {
	        str = str.substring(0, str.length() - 1);
	    }
	    return str;
	}
	
	//method to set terms to relations 
	private static void setTerms(String xmlTerm, String termKey, Relations r, List<?> termsList)
	{
		String termString = null;
		for (int a = 0; a < termsList.size(); a++) 
		{	
			Element termsNode = (Element) termsList.get(a);

			//go inside Terms and get all term elements
			List <?> inTerms = termsNode.getChildren(xmlTerm);
			Terms terms = new Terms();
			
			for (int x = 0; x < inTerms.size(); x++) 
			{
				Element inNode = (Element) inTerms.get(x);
				termString = inNode.getText();
				//take out any quotation
				if(termString.contains("\""))
				{
					termString = termString.replace("\"", "");
				}
				terms.addTerm(termString);
				r.setTerms(termKey,terms);				
			}
		}
	}
	
	//method to get and add terms to triplets
	private static void addTerms(List<Terms> termsList, StringBuilder trip) 
    {
		Terms term = new Terms();
		if(termsList != null) 
		{
			for(int i=0; i< termsList.size(); i++)
			{
				term = termsList.get(i);
			}
			
			List<String> termStr = term.getTerms();
			for(int x = 0; x < termStr.size();x++) 
			{
				String terms = termStr.get(x);
				
				//remove any ending periods
				if(terms.contains(". ") || terms.charAt(terms.length() - 1) == '.')
				{
					terms = removeEndPer(terms);
				}
				
				String s = new String();
				String st = new String();

				//adding & or AND of terms that contain them
				if(!s.equalsIgnoreCase(terms) && !st.equalsIgnoreCase(terms)) 
				{
					trip.append("\"" +terms+ "\"");
				}				
					
				if(terms.contains(" and ") || terms.contains(" & ")) 
				{
					s = addAnd(terms, trip);
					if(s != null)
					{
						trip.append("\"");
						s = s.replace("\"", "\"\"");
						trip.append(s + "\"");
					}
				}
					
				if(terms.contains(".")) 
				{
					st = terms.replace(".", "");

					if(st != null && !trip.toString().contains(st) )
					{
						trip.append("\"");
						st = st.replace("\"", "\"\"");
						trip.append(st + "\"");
					}
				}
			}	
		}
    }
	
    //method to delete duplicates
	private static String deleteDup(String trip, String nameFirst, String nameLast, String birthLast) 
	{
	   String triplets = trip;
	   
	   List<String> words = new ArrayList<String>();
	   List<String> phrases = new ArrayList<String>();
	   String word = null;
	   String phrase = null;
	   CharSequence target = null ;
	   String removed = null;
	   
       StringTokenizer st1 = new StringTokenizer(triplets, ")\""); 
       
       while(st1.hasMoreTokens()) 
       {
    	   word = st1.nextToken().trim();
    	   //kLogger.debug("PHRASE: "+word);
    	   words.add(word);
    	   }
       
       for(int i = 0; i < words.size(); i++) 
       {
    	   if(!words.get(i).equals(" ") && words.get(i).length() < 65) 
    	   {
    		   phrase = words.get(i);
	       phrases.add(phrase);
	       }
       }
       
       //if triplets contains any of the phrases in phrases remove from triplets
       for (int a = 0; a < phrases.size(); a ++) 
       {
	    	   String tripRev = new StringBuffer(trip).reverse().toString();
	    	   if(countNeedlesInHaystack( trip, "\""+phrases.get(a)+"\"") > 1)
	    	   {
	    		   target = phrases.get(a);
	    		   //add conditional to not check phrases that are just a persons nameFirst or nameLast or birthLast
	    		   if(!target.equals(nameFirst) && !target.equals(nameLast) && !target.equals(birthLast)) {
		    		   String targetRev = new StringBuffer(target).reverse().toString();
		    		   
			       removed = tripRev.replaceFirst(("\"" +targetRev+ "\""), "");
			       removed = new StringBuffer(removed).reverse().toString();
			       
			       trip = removed;
		    		   }
		   }
       }
       if(removed != null) 
       {
    			return removed;
       }
       else 
    	   	return trip;
    }

	//method to add OR between phrases
	private static String addOr(StringBuilder trip) 
	{
		CharSequence target = "\"\"";
		CharSequence replacement = "\" OR \"";
		String newString = null;
		
		for(int i = 0; i < trip.length(); i++) 
		{
    			newString = trip.toString().replace(target, replacement);
    		}
    		return newString;
    }
	
	//method to replace &
	private static String replaceAmp(StringBuilder trip) 
	{
		CharSequence target = " & ";
		CharSequence replacement = " ";
		String newString = null;
		
		for(int i = 0; i < trip.length(); i++) 
		{
    			newString = trip.toString().replace(target, replacement);

    		}

    		return newString;
    }
	
	//method to eliminate any empty tags
    private static void handleNode(Element element) 
    {
        if (element.getChildren().size() == 0 && "".equals(element.getValue())) 
        {
        	element.getParent().removeContent(element);
            return;
        }
        // recurse the children
        for (int i = 0; i < element.getChildren().size(); i++) 
        { 
            handleNode((Element) element.getChildren().get(i));
        }
    }
    
	//method to get organizations in form
    private static void initOrgs( List <Element> list, List <String> organs ) 
    {
		for (int i = 0; i < list.size(); i++) 
		{
			//handleNode(rootNode);
			Element node = list.get(i);				
			
			@SuppressWarnings("unchecked")
			List <Element> organizations = node.getChildren("org");
			Iterator <Element> oIt = organizations.iterator();
		
			while(oIt.hasNext())
			{
				Element o = oIt.next();
				//remove any ending periods
				if(o.getText().contains(". ") || o.getText().charAt(o.getText().length() - 1) == '.')
				{
					String o2 = removeEndPer(o.getText());
					o.setText(o2);
				}
				organs.add(o.getText());
				
				//if o still contains a period, strip the period and add the new version to organs
				if(o.getText().contains("."))
				{
					String o2 = o.getText().replace(".", "");
					organs.add(o2);
				}
				//if o contains &/and make a new version with the opposite and add new version to organs
				if(o.getText().contains(" and ") || o.getText().contains(" & ")) 
				{
					StringBuilder orgBuilder = new StringBuilder();
					orgBuilder.append(organs.get(organs.size() - 1));
					String o2 = addAnd(o.getText(), orgBuilder);
					if(o2 != null)
					{
						organs.add(o2);
					}
				}
			}
		}
    }

    //method to take care of and/& variations 
    private static String addAnd(String string, StringBuilder trip) 
    {
    		String newString = null;

    		if(string.contains(" and ")) 
    		{	
    			newString = string.replace(" and ", " & ");
    			if(trip.toString().contains(newString)) 
    			{
    				newString = "";
    			}
    			else 
    				newString = newString.replace(" & ", " ");
    		}
    		else if(string.contains(" AND ")) 
    		{	
    			newString = string.replace(" AND ", " & ");
    			if(trip.toString().contains(newString)) 
    			{
    				newString = "";
    			}
    			else 
    				newString = newString.replace(" & ", " ");
    		}
    		else if(string.contains(" & ")) 
    		{	
    			newString = string.replace(" & ", " and ");
    			if(trip.toString().contains(newString)) 
    			{
    				newString = "";
    			}
    		}
    		else if(string.contains(" &amp; ")) 
    		{	
    			newString = string.replace(" &amp; ", " and ");
    			if(trip.toString().contains(newString)) 
    			{
    				newString = "";
    			}
    		}
    		else 
    			newString = "";    		
    		
    		return newString;
    }

    
    /**method to take care of duplicate phrases split problem
    * How many times does the needle occur in the string 'haystack'?
    * @param haystack
    * @param needle
    * @return
    */
    public static int countNeedlesInHaystack(String haystack, String needle) {
        int retval = 0;
        int offset = 0;
        while( (offset = haystack.indexOf(needle, offset)) != -1 ) {
               retval += 1;
               offset += 1;
        }
        return retval;
    }
    
	@Override
	public PermutedResult convert(String inData, String inFormat, Map <String,String> options) throws Throwable 
	{
		int theCount = 0;
		String option=null;
		String docInfo = null;
		String scorelimit=null;
		String tripletData = null;
		String gatewayResult = null;
		Relations r = process(inData);
		StringBuilder docrefs = new StringBuilder();
		StringBuilder docrefsFinal = new StringBuilder();
		
		tripletData = this.permute(r)+"&searchLogtf=true";
		
		if (!StringUtils.isEmpty(extraQuery))
		{
			//remove scorelimit and option from gateway request then add it back to triplet data
			//so it can be used in rankEvidence
			if(extraQuery.contains("scorelimit"))
			{
				String [] eQuery = extraQuery.split("scorelimit");
				scorelimit="&scorelimit"+eQuery[1];
				String td = tripletData.replace(scorelimit, "");
				tripletData=null;
				tripletData=td;
			}
			if(extraQuery.contains("option"))
			{
				String [] eQuery = extraQuery.split("option");
				option="&option"+eQuery[1];
				String o = tripletData.replace(option, "");
				tripletData=null;
				tripletData=o;
			}
			//revome '-' if it got included in maxhits value
			if(tripletData.contains("maxhits=-")) 
			{
				String tdata = tripletData.replace("maxhits=-", "maxhits=");
				tripletData = null;
				tripletData = tdata;
			}
			
			// call the build URL w/triplet data and extra query; call gateway and return result
			GatewaySearch gs= new GatewaySearch();
			String url =null;
			GatewaySearch gsearch= new GatewaySearch();
			String url2 =null;
			
			//if rankEvidence is not needed do this ------------------------------------------------------------------------
			if(option!=null && (option.contains("norank") || option.contains("docref")) ) 
			{
				if(tripletData.contains("maxhits")) 
			 	{
					//make sure maxhits has the '-' in front since it is a fed call
					if(!tripletData.contains("maxhits=-")) 
					{
						String tdata=tripletData.replace("maxhits", "maxhits=-");
						tripletData = null;
						tripletData = tdata;
					}
					url=gs.getURL(tripletData + "&offset=1","fed");
			 		}
					else 
					{
						url=gs.getURL(tripletData + "&offset=1&maxhits=-120","fed");
					}
					//kLogger.debug("gateway fedsearch URL: "+url);
				
					// should split the pieces at the question mark
					int theQueryIndex = url.indexOf('?');
					gatewayResult = gs.getDocument(url.substring(0, theQueryIndex), url.substring(theQueryIndex+1));
				
					if(option.contains("docref")) 
					{
						SAXBuilder builder = new SAXBuilder();
						Document document = (Document) builder.build(new StringReader(gatewayResult));
					 
						Element resultList = document.getRootElement();
						Element fedtask = resultList.getChild("fedtask");
						Element result = fedtask.getChild("result");
						Element hitlist = result.getChild("hitlist");
						@SuppressWarnings("rawtypes")
						Iterator listIt = hitlist.getChildren("hit").iterator();
					 
						boolean b = false;
						//grab all docrefs (make sure there are hits first)
						if(!gatewayResult.contains("total=\"0\"")) 
						{
							while (listIt.hasNext()) 
							{
								Element hit = (Element) listIt.next();
								String docref = hit.getChildText("docref");
								if(b == true)
								{
									docrefs.append(",");
								}
								docrefs.append(docref);
								b = true;
							}
							docrefs.toString().substring(0,docrefs.length()-1);
	
							String [] arr = docrefs.toString().split(",");
							docrefsFinal.append("<docrefs>");
							for(int x = 0; x < arr.length;x++) 
							{
								theCount++;
								docrefsFinal.append("<docref>"+arr[x]+"</docref>");
							}
	
							docrefsFinal.append("<count>"+theCount+"</count>");
							docrefsFinal.append("</docrefs>");
							return new PermutedResult("text/plain", docrefsFinal.toString());
						}
						else
						{
							return new PermutedResult("text/xml;charset=UTF-8", "<docrefs>\n" + 
									"  <count>0</count>\n" + 
									"</docrefs>");
						}
					}
					else
						return new PermutedResult("text/plain", gatewayResult);
				}

			// ---------------------------------------------------------------------------------------------------------------
			else if (option != null && (option.contains("evidscore-cutoff") || option.contains("evidencescore"))) 
			{
				//eric's endpoint call
				if(tripletData.contains("maxhits")) 
				{
					url=gs.getURL(tripletData + "&sort=_rank_%3AD&offset=1","doc");
				}
				else 
				{
					url=gs.getURL(tripletData + "&sort=_rank_%3AD&offset=1&maxhits=120","doc");
				}
				//regular gateway call
				if(tripletData.contains("maxhits")) 
				{
					url2=gsearch.getURL(tripletData + "&sort=_rank_%3AD&offset=1","fed");
				}
				else 
				{
					url2=gsearch.getURL(tripletData + "&sort=_rank_%3AD&offset=1&maxhits=-120","fed");
				}
				//kLogger.debug("gateway fedsearch URL: "+url);
		
				// should split the pieces at the question mark
				int theQueryIndex = url.indexOf('?');
				int queryIndex = url2.indexOf('?');
				docInfo = gs.getDocument(url.substring(0, theQueryIndex), url.substring(theQueryIndex+1));
				gatewayResult = gs.getDocument(url2.substring(0, queryIndex), url2.substring(queryIndex+1));
				
				if(gatewayResult.isEmpty() || gatewayResult.contains("total=\"0\"") 
						|| docInfo.contains("count=\"0\"") || docInfo.isEmpty() )
				{
					GatewaySearch gs2= new GatewaySearch();
					String emptycall = gs2.getURL(tripletData ,"fed");
					int theQueryIndex2 = emptycall.indexOf('?');
					String gatewayResultEmpty = gs2.getDocument(emptycall.substring(0, theQueryIndex2), emptycall.substring(theQueryIndex2+1));
					return new PermutedResult("text/xml;charset=UTF-8", gatewayResultEmpty);
				}
				else 
				{
					String output = null;
					if(scorelimit != null && option != null) 
					{
						output = RankEvidence.process(gatewayResult, docInfo, tripletData+scorelimit+option);
					}
					else if (scorelimit != null) 
					{
						output = RankEvidence.process(gatewayResult, docInfo, tripletData+scorelimit);
					}	
					else if (option != null) 
					{
						output = RankEvidence.process(gatewayResult, docInfo, tripletData+option);
					}
					else if (scorelimit ==null && option == null) 
					{
						output = RankEvidence.process(gatewayResult, docInfo, tripletData);
					}
					return new PermutedResult("text/plain", output);
				}
			}
			// no options ---------------------------------------------------------------------------------------------------------------
			else {
				//eric's endpoint call
				if(tripletData.contains("maxhits")) 
				{
					url=gs.getURL(tripletData + "&sort=_rank_%3AD&offset=1","doc");
				}
				else 
				{
					url=gs.getURL(tripletData + "&sort=_rank_%3AD&offset=1&maxhits=120","doc");
				}

				//kLogger.debug("gateway fedsearch URL: "+url);
		
				// should split the pieces at the question mark
				int theQueryIndex = url.indexOf('?');
				docInfo = gs.getDocument(url.substring(0, theQueryIndex), url.substring(theQueryIndex+1));
				
				if(docInfo.isEmpty() || docInfo.contains("count=\"0\""))
				{
					GatewaySearch gs2= new GatewaySearch();
					String emptycall = gs2.getURL(tripletData ,"fed");
					int theQueryIndex2 = emptycall.indexOf('?');
					String gatewayResultEmpty = gs2.getDocument(emptycall.substring(0, theQueryIndex2), emptycall.substring(theQueryIndex2+1));
					return new PermutedResult("text/xml;charset=UTF-8", gatewayResultEmpty);
				}
				else 
				{
					String output = null;
					String gateway = null;
					if(scorelimit != null && option != null) 
					{
						output = RankEvidence.process(gateway, docInfo, tripletData+scorelimit+option);
					}
					else if (scorelimit != null) 
					{
						output = RankEvidence.process(gateway, docInfo, tripletData+scorelimit);
					}	
					else if (option != null) 
					{
						output = RankEvidence.process(gateway, docInfo, tripletData+option);
					}
					else if (scorelimit ==null && option == null) 
					{
						output = RankEvidence.process(gateway, docInfo, tripletData);
					}
					return new PermutedResult("text/plain", output);
				} 
			}
		}
		else
			return new PermutedResult("text/plain", tripletData);
	}
}